
<!DOCTYPE html>
<html lang="en" class="loading">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>he is bored - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="ICERRA,"> 
    <meta name="description" content="最长回文子串做过判断是否是回文的，这个没做过。
题干：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
示例 1：
123输入: &amp;quot;babad&amp;qu,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">he is bored</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">he is bored</h1>
        <div class="stuff">
            <span>九月 25, 2019</span>
            

        </div>
        <div class="content markdown">
            <h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>做过判断是否是回文的，这个没做过。</p>
<p>题干：给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p><strong>方法一：最长公共子串</strong></p>
<p>常见错误： </p>
<p>​       反转s，使之变为s‘，来寻找s和s’的最长公共子串。这个方法感觉挺简单的，但比如s=abacdfgdcaba，s‘=……  它们两个最长公共子串是abacd，然而这并不是回文。</p>
<p>​       我们可以看到，当 SS 的其他部分中存在非回文子串的反向副本时，最长公共子串法就会失败。为了纠正这一点，每当我们找到最长的公共子串的候选项时，都需要检查子串的索引是否与反向子串的原始索引相同。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。</p>
<p>（未手写实现）</p>
<p>  ps：求最长公共子串：<a href="https://www.kancloud.cn/digest/pieces-algorithm/163624" target="_blank" rel="noopener">https://www.kancloud.cn/digest/pieces-algorithm/163624</a></p>
<p><strong>方法二：暴力法</strong></p>
<p>​    选出所有子字符串可能的开始和结束位置，并检测它是不是回文。（真的暴力）</p>
<p><strong>方法三：动态规划</strong></p>
<p>   对暴力法的改进，需要观察如何避免在验证回文时进行不必要的重复计算，比如考虑ababa，如果已知bab是回文，那么很明显ababa是回文因为左首字母和右尾字母是相同的。</p>
<p>我们给出 P(i,j)的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我直接给网站不就好了</span><br><span class="line">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/</span><br></pre></td></tr></table></figure>

<p>  不会写</p>
<p><strong>方法四：中心扩展算法</strong></p>
<p>  事实上，只需使用恒定的空间，我们就可以在 O(n^2) 的时间内解决这个问题。</p>
<p>我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n - 1个这样的中心。你可能会问，为什么会是 2n - 1个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如“abba” 的中心在两个‘b’ 之间）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">//两种情况区别见：</span></span><br><span class="line">                                         <span class="comment">// https://www.zhihu.com/question/19858118</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;        <span class="comment">//向两边扩展</span></span><br><span class="line">        <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);        <span class="comment">//单点扩展</span></span><br><span class="line">        <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);    <span class="comment">//双点扩展</span></span><br><span class="line">        <span class="keyword">int</span> len = Math.max(len1, len2);   <span class="comment">//取i=3，成功一次，len=2</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start) &#123;       <span class="comment">//超出本次区间 选出新区间</span></span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//start=3</span></span><br><span class="line">            end = i + len / <span class="number">2</span>;        <span class="comment">//end=3+1=4  这全是找规律得的吧</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);  <span class="comment">//substring返回字符串的子字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;   <span class="comment">//返回某一区间内回文长度</span></span><br><span class="line">    <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">        L--;</span><br><span class="line">        R++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R - L - <span class="number">1</span>; <span class="comment">//比如i=3,成功了一次，此时L=2,R=4，长度为1；若为i，i+1；成功一次，则L=2，R=5,长度为2，还是R-L-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他人笔记：</p>
<p>​        来解释一下为什么中心是2n-1而不是n 比如有字符串abcba，这时回文子串是abcda，中心是c；又有字符串adccda，这时回文子串是adccda，中心是cc。 由此可见中心点既有可能是一个字符，也有可能是两个字符，当中心为一个字符的时候有n个中心，当中心为两个字符的时候有n-1个中心，所以一共有2n-1个中心。 然后for循环开始从左到右遍历，为什么会有两次expandAroundCenter，一次是i和i本身，一次是i和i+1，这就是上面说到的一个中心与两个中心。 而后会去判断这两种情况下谁的回文子串最长，并标记出这个子串在原字符串中的定位，即start和end。</p>
<p><strong>方法五：Manacher算法</strong></p>
<p>参考： <a href="https://segmentfault.com/a/1190000008484167" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008484167</a>   下面的代码搭配看比较好</p>
<p>java中String不可变，StringBuilder可变。这个转成用hashset做？</p>
<p>java如何将char数组转化为string：<a href="https://blog.csdn.net/guo0820/article/details/51194588" target="_blank" rel="noopener">https://blog.csdn.net/guo0820/article/details/51194588</a></p>
<p>hashset转字符串：<a href="https://blog.csdn.net/RSun1/article/details/8138807" target="_blank" rel="noopener">https://blog.csdn.net/RSun1/article/details/8138807</a></p>
<p>有直接将字符串转换为字符数组的方法：toCharArray()</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> ||s.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">char</span>[] arr = manacharString(s);  <span class="comment">//转换成扩充后的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] parr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">int</span> pr = -<span class="number">1</span>;   <span class="comment">//右半径</span></span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>; <span class="comment">//中心点</span></span><br><span class="line">    <span class="keyword">int</span> maxindex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxpr = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i!=arr.length;i++)&#123;   <span class="comment">//arr</span></span><br><span class="line">        parr[i] = pr &gt; i?Math.min(parr[<span class="number">2</span>*index - i],pr-i) : <span class="number">1</span>;   <span class="comment">//parr是个辅助工具</span></span><br><span class="line">        <span class="keyword">while</span>(i+parr[i] &lt;arr.length &amp;&amp; i-parr[i] &gt;= <span class="number">0</span>)&#123;  <span class="comment">//向外扩展</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i+parr[i]] == arr[i-parr[i]])&#123; <span class="comment">//用于判断的是arr</span></span><br><span class="line">                parr[i]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;                   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+parr[i] &gt; pr)&#123;  <span class="comment">//更新index pr</span></span><br><span class="line">            pr = i+parr[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(parr[i] &gt; maxpr)&#123;</span><br><span class="line">            maxindex = i;</span><br><span class="line">            maxpr = parr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> begin = maxindex/<span class="number">2</span>-((maxpr-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> s.substring(begin,begin+maxpr-<span class="number">1</span>); <span class="comment">//最后返回的还是原始字符串的子字符串</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//ok</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] manacharString(String str)&#123;</span><br><span class="line">    <span class="keyword">char</span>[] charArr = str.toCharArray();   <span class="comment">//将字符串转换为字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[str.length()*<span class="number">2</span>+<span class="number">1</span>];   <span class="comment">//扩充后的新数组</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++) <span class="comment">//注意不是res.length()，直接访问即可</span></span><br><span class="line">        res[i] = (i&amp;<span class="number">1</span>) == <span class="number">0</span>? <span class="string">'#'</span>:charArr[index++];  <span class="comment">//偶数填充#，变为#a#b#c#d#等</span></span><br><span class="line">    <span class="keyword">return</span> res;  <span class="comment">//返回填充后的字符数组</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DLL1:塞尔达进度</strong></p>
<p>   平时没空玩，昨天把骆驼打了，卡了一个多月的主线终于向前推进了一点，目前在风之神兽上，不过不太想推太快，先缓一缓接着开荒吧。</p>
<p><strong>DLL2:每日一图</strong></p>
<p><img src="/images/qipao.jpeg" alt></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/5146554.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/qq/001faIUs4M2zna.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
